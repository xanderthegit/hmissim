if(!require(yaml)) install.packages(yaml)
if(!require(httr)) install.packages(httr)

readDictionary <- function(dictionary) {
  # given the dictionary repo name, return the whole json file for that dictionary
  #
  # Args:
  #   repo: dictionary repo name, eg: 'bpadictionary'
  #   branch: repo branch
  #
  # Returns:
  #   dictionary_nodes:  R object with two lists: 
  #      node_list: contain  dictionary nodes
  #      helper_yaml: contain information representing persistent definitions, settings and terms
  
  #dict_json_path <- paste(c(dictionary , "/", branch ,"/schema.json"), collapse ="")
  dict_json_path <- paste(dictionary, collapse ="")
  dictionary_json <- fromJSON(dict_json_path)
  
  altdefs <- grep("^_", names(dictionary_json), value = TRUE)
  metaschema <- grep("metaschema.yaml", names(dictionary_json), value = TRUE)
  program <- grep("program.yaml", names(dictionary_json), value = TRUE)
  project <- grep("project.yaml", names(dictionary_json), value = TRUE)

  altdefs <- c(altdefs, metaschema, program, project)
  helper <- dictionary_json[names(dictionary_json) %in% altdefs]
  nodes <- dictionary_json[!names(dictionary_json) %in% altdefs]
  
  dictionary_nodes <- list(node_list = nodes,
                           helper_yaml = helper)
  
  return(dictionary_nodes)
  
}

## Create Node_Compendium and Compendium from Dictionary

buildCompendiums <- function(dictionary) {
  # given the raw dictionary, build a base compendium table
  # and a node relationship table to prep for simulation
  #
  # Args:
  #   dictionary: list of node links generated by the readDictionary 
  #       function
  #
  # Returns:
  #   compendiums_objects:  R object with two lists: 
  #      compendium: representing all variables in the dictionary
  #      compendium_nodes:  representing the relationship between 
  #        nodes in the dictionary
  
  # initialize empty DFs to store objects
  compendium_nodes <- data.frame(NODE = character(), 
                                 TITLE = character(),
                                 CATEGORY = character(),
                                 DESCRIPTION = character(),
                                 LINK_NAME = character(),
                                 BACKREF = character(),
                                 LABEL = character(),
                                 TARGET = character(),
                                 MULTIPLICITY = character(), 
                                 LINK_REQUIRED = character()) 
  compendium <- data.frame(DESCRIPTION = character(),
                           NODE = character(),
                           VARIABLE = character(),
                           REQUIRED = logical(), 
                           TYPE = character(),
                           CHOICES = character(), 
                           TEMPCHOICES = numeric(),
                           MAX = numeric(),
                           MIN = numeric())
  
  # get objects from dictionary
  node_list <- dictionary$node_list
  # loop through nodes to generate rows in compendium
  # and compendium nodes
  for (node in node_list) {
      # get node relationships/links
      if (nrow(node$links) > 1){
          links <- node$links[node$links$required,]
      }
      else{
          links <- node$links
      }
    
      # get compendium_nodes field definitions
      link_name <- NA
      backref <- NA
      label <- NA
      target <- NA
      multiplicity <- NA
      link_required <- NA      
      if ('name' %in% names(links)) {
          # if there is no link multiplicity
          link_pos <- !is.na(links[['name']])
          link_name <- links[['name']][link_pos]
          backref <- links[['backref']][link_pos]
          label <- links[['label']][link_pos]
          target <- links[['target_type']][link_pos]
          multiplicity <- links[['multiplicity']][link_pos]
          link_required <- links[['required']][link_pos]
      } 
      if ('subgroup' %in% names(links) && !is.null(links$subgroup[[1]])) {
          exclusive <- links$exclusive[!is.na(links$exclusive)]
          if (exclusive){
             link_pos <- 1
          }
          else{
             link_pos <- 1:nrow(links$subgroup[[1]])
          }
          link_name <- c(link_name, links$subgroup[[1]][['name']][link_pos])
          link_name <- link_name[!is.na(link_name)]
          backref <- c(backref, links$subgroup[[1]][['backref']][link_pos])
          backref <- backref[!is.na(backref)]
          label <- c(label, links$subgroup[[1]][['label']][link_pos])
          label <- label[!is.na(label)]
          target <- c(target, links$subgroup[[1]][['target_type']][link_pos])
          target <- target[!is.na(target)]
          multiplicity <- c(multiplicity, links$subgroup[[1]][['multiplicity']][link_pos])
          multiplicity <- multiplicity[!is.na(multiplicity)]
          link_required <- c(link_required, links$subgroup[[1]][['required']][link_pos])
          link_required <- link_required[!is.na(link_required)]
      }

      links_list <- tryCatch(
        {
          links_list <- data.frame(NODE = node$id,
                                   TITLE = node$title,
                                   CATEGORY = node$category,
                                   DESCRIPTION = node$description,
                                   LINK_NAME = link_name,
                                   BACKREF = backref,
                                   LABEL = label,
                                   TARGET = target,
                                   MULTIPLICITY = multiplicity, 
                                   LINK_REQUIRED = link_required)
        },
        error=function(cond) {
          message(paste("Skipping creation of table row ", node$title))
          message('')
        },
        warning=function(cond) {
          message(paste("Warning created: ", node$title))
        }
      )       
      
      if(inherits(links_list, "error")) next
      
      compendium_nodes <- rbind(compendium_nodes, links_list)
      
      ## Get variables and append to compendium df
      
      NODE <- node$id
      # get list of variables
      fields <- node$properties
      linktoremove <- unlist(node$links)[grepl("name", names(unlist(node$links)))]
      fieldnames <- names(fields) 
      refs <- fields[grepl("\\$ref", names(fields))]
      
      # check nested props in ref
      for(refname in names(refs)){
        ref <- refs[[refname]]
        if(!is.null(ref)){
          for(r in ref){
            reference <- strsplit(r,"#/")[[1]]
            reffile <- reference[1]
            if(reffile %in% names(dictionary$helper_yaml)){
                nested <- dictionary$helper_yaml[[reffile]]
            }
            else{
                nested <- dictionary$node_list[[reffile]]
            }
            
            nested_fields <- names(nested[[reference[2]]])
            for (f in nested_fields){
              field <- nested[[reference[2]]][[f]]
              if('$ref' %in% names(field)){
                fields[[f]] <- nested[[f]]
              }
              else{
                fields[[f]] <- field
              }
            }
            fieldnames <- c(fieldnames, nested_fields)
          }
        }
      }
        
      #don't include $ref and other internal variables #PROVISIONALLY HARD CODED
      excluded_fields <- c(names(refs), "type", "error_type", "state", "id",
                           "file_state", "created_datetime", "updated_datetime",
                           "state", "state_comment", "project_id", "submitter_id",
                           "workflow_start_datetime", "workflow_end_datetime", 
                           "sequencing_date", "run_datetime", "object_id")
      fieldnames <- fieldnames[!fieldnames %in% linktoremove]
      fieldnames <- fieldnames[!(fieldnames %in% excluded_fields)]
      required <- node$required            
 
      # loop through fields in node to get variables
      for (f in fieldnames) {
        if ("$ref" %in% names(fields[[f]])){ 
          if ('type' %in% names(fields[[f]]) | 'enum' %in% names(fields[[f]])) next
          else {
            
            # Check nested property
            ref <- fields[[f]]$`$ref`
            reference <- strsplit(ref,"#/")[[1]]
            reffile <- reference[1]
            property <- reference[2]
            if (grepl("/", property) > 0){
              property <- strsplit(property,"/")[[1]]
              definitions <- dictionary$node_list[[reffile]]
            }
            else{
              definitions <- dictionary$helper_yaml[[reffile]]
            }
                        
            if (length(property) > 1){
              fields[[f]] <- definitions[[property[1]]][[property[2]]] 
            }
            else{
              fields[[f]] <- definitions[[property]]
            }
          }
        }
        
        if ('description' %in% names(fields[[f]])) {
          DESCRIPTION = fields[[f]]$description
        } else {
          DESCRIPTION = paste0("See : ", fields[[f]]["term"]$`$ref`)
        }
        
        if ('enum' %in% names(fields[[f]])) {
          TYPE <- 'enum'
          elements <- fields[[f]]$enum
          CHOICES <- paste(elements, collapse='|')
          TEMPCHOICES <- length(elements)
          MAX <- NA
          MIN <- NA                
        } else {
          if ('type' %in% names(fields[[f]])){    
            TYPE <- fields[[f]]$type[1]
          }              
          else if ('oneOf' %in% names(fields[[f]])){
            TYPE <- fields[[f]]$oneOf$type[1]
          }
          CHOICES <- ''
          if ('pattern' %in% names(fields[[f]])){
            CHOICES <- fields[[f]]$pattern[1]
          }
          else if (f == 'md5sum'){
            CHOICES <- "^[a-f0-9]{32}$"
          }
          TEMPCHOICES <- 0
          MAX <- NA
          MIN <- NA
          if ('maximum' %in% names(fields[[f]])){
            MAX <- fields[[f]]$maximum
          }
          if ('minimum' %in% names(fields[[f]])){
            MIN <- fields[[f]]$minimum
          }                
        }
        
        if (f %in% required) {
          REQUIRED <- TRUE
        } else {
          REQUIRED <- FALSE
        }

        var_list <- tryCatch(
          {
            var_list <- data.frame(
              DESCRIPTION = DESCRIPTION,
              NODE = NODE,
              VARIABLE = paste0(f, ".", NODE),
              REQUIRED = REQUIRED,
              TYPE = TYPE,
              CHOICES = CHOICES,
              TEMPCHOICES = TEMPCHOICES,
              MAX = MAX,
              MIN = MIN)
          },
          error=function(cond) {
            message(paste("Error creating variable ", f, " on node ", node$id))
            message(cond)
            message('')
          },
          warning=function(cond) {
            message(paste("Warning created: ", f))
          }                
        ) 
        
        compendium <- rbind(compendium, var_list)
      }      
  }

  ## Add sim values to compendium
  getEnumProbs <- function(df){
    probs <- c()
    for(i in 1:nrow(df)) {
      row <- df[i,]
      num <- row[['TEMPCHOICES']]
      if (num == '') {probs_new = ''} else {
        probs_new <- paste(rep(1/num, num), collapse='|')
        probs <- c(probs, probs_new)
      }
    }
    return(probs)
  }
  compendium$DESCRIPTION <- as.character(compendium$DESCRIPTION)
  compendium$NODE <- as.character(compendium$NODE)
  compendium$VARIABLE <- as.character(compendium$VARIABLE)
  compendium$CHOICES <- as.character(compendium$CHOICES)
  compendium$TYPE <- as.character(compendium$TYPE)
  
  compendium$PROBS <- getEnumProbs(compendium)
  compendium$PROBS[compendium$TYPE=='boolean'] <- c('.4|.6')
  compendium$TEMPCHOICES <- NULL
  
  compendium$DISTRIB <- ''
  compendium$DISTRIB[compendium$TYPE=='integer'] <- 'poisson'
  compendium$DISTRIB[compendium$TYPE=='number'] <- 'normal'
  
  compendium$DISTRIB.INPUTS <- ''
  compendium$DISTRIB.INPUTS[compendium$TYPE=='integer'] <- 'lambda = 4'
  compendium$DISTRIB.INPUTS[compendium$TYPE=='number'] <- 'mean = 10, sd = 3'
  
  # update number/integer distribution if a range is provided
  means <- (compendium$MAX[compendium$TYPE=='integer' &!is.na(compendium$MIN)] + compendium$MIN[compendium$TYPE=='integer' &!is.na(compendium$MIN)]) / 2         
  compendium$DISTRIB.INPUTS[compendium$TYPE=='integer' & !is.na(compendium$MIN)] <- paste("lambda = ", as.character(means), sep="")
  means <- (compendium$MAX[compendium$TYPE=='number' &!is.na(compendium$MIN)] + compendium$MIN[compendium$TYPE=='number' &!is.na(compendium$MIN)]) / 2         
  compendium$DISTRIB.INPUTS[compendium$TYPE=='number' & !is.na(compendium$MIN)] <- paste("mean = ", as.character(means), ", sd = 10", sep="")
  
  
  compendium$NAS <- runif(nrow(compendium), 0, .2)
  compendium$POSITIVEONLY <- ''
  
  # create final object with compendium and compendium node relationships
  compendium_objects <- list(compendium = compendium,
                             compendium_nodes = compendium_nodes)
  return(compendium_objects)  
    
}

simFromDictionary <- function(dictionary, project_name, required_only=F, n, output_to_json=F, dir=NULL) {
  # given the raw dictionary, build a base compendium table
  # and a node relationship table and run simulation
  #
  # Args:
  #   dictionary: dictionary repo name, eg: 'bpadictionary'
  #   branch: branch name to use for desired dictionary  
  #   required_only: to subset compendium so that only required fields are simmed
  #   n: number of sims for each variable
  #   output_to_json:  create output json files
  #   dir: output for json files
  #
  # Returns:
  #   simdata and json files in output directory
  
  print("Loading Simulation Tools...")
  source('SimtoJson.R')
  source('SimData.R')
    
  print("Getting JSON form dictionary...") 
  dictionary <- readDictionary(dictionary)
  
  print("Creating Compendium and Node Relationship Table...")
  compendiumObjects <- buildCompendiums(dictionary)
  compendium <- compendiumObjects$compendium
  
  if (required_only) {
    compendium <- compendium[compendium$REQUIRED==TRUE,]
  } 
  
  node_levels <- gen_node_levels(compendium, compendiumObjects, dir)
  sorted_nodes <- gen_submitted_orders(compendium, compendiumObjects, dir)
  sample_numbers = generate_node_instance_numbers(sorted_nodes, node_levels, n_max)
  
  print("Simulating Data...")
  simdata <- simData(compendium, 
                     sample_numbers,
                     include.na = FALSE, 
                     reject= FALSE)

  if (output_to_json) {
    print("Generating Json...")
    SimtoJson(simdata, 
              compendium, 
              compendiumObjects$compendium_nodes,
              sorted_nodes,
              project_name,
              dir)
  }
  
  return(simdata)
  
}

generate_node_instance_numbers <- function(sorted_nodes, node_levels, n_max){
  # Give a node levels and sorted node list, randomly compute the number 
  # of instances for each node. The nodes which are close to the root
  # will get the least number of instances
  # 
  # Args:
  #   sorted_nodes(list(str)): list of sorted nodes
  #   node_levels(list(integer)): list of node levels
  #   n_max(integer): the maximum instance numbers
  # 
  # Returns:
  #   list(integer): list of node instance numbers
  
  sample_numbers <- c()
  max_level = max(node_levels)
  for(node in sorted_nodes) {
      factor = sample(2:3,1)
      mean = max(20,min(factor**node_levels[[node]], n_max))
      val = sample(as.integer(0.8*mean):as.integer(1.2*mean),1)
      sample_numbers <- c(sample_numbers, val)
  }
  names(sample_numbers) <- sorted_nodes
    return(sample_numbers)
}

get_reversed_neighbors <- function(nodes, compendiumObjects) {
  # Compute reversed neighbors for each node.
  # 
  # Args:
  #   nodes(list(str)): list of nodes
  #   compendiumsObjects:  R object with two lists
  # 
  # Returns:
  #   list(list(str)): list of reversed neighbors
    reversed_neighbors <- rep(list(list()),length(nodes))
    names(reversed_neighbors) <- nodes
    
    for(node in nodes) {
        targets <- as.character(compendiumObjects$compendium_nodes[['TARGET']][compendiumObjects$compendium_nodes[['NODE']]==node])
        for(target in targets) {
          reversed_neighbors[[target]] <- c(node,reversed_neighbors[[target]])
        }
    }
    return(reversed_neighbors)
}

gen_node_levels <- function(compendium, compendiumObjects, path) {
  # Generate node levels from root (project)
  # 
  # Args:
  #   compendium(data.frame): representing all variables in the dictionary
  #   compendiumsObjects:  R object with two lists
  # 
  # Returns:
  #   list(integer): list of node levels
  
  nodes <- unique(compendium[['NODE']])
  nodes <- c("project", nodes)
  neighbors <- get_reversed_neighbors(nodes, compendiumObjects)
  
  visited = rep(FALSE, length(nodes))
  names(visited) <- nodes
  
  levels <- rep(0, length(nodes))
  names(levels) <- nodes
  last <- 1
  visited[["project"]] <- TRUE
  queue <- c("project")
  
  # Do BFS from root
  while (last <= length(queue)) {
      node <- queue[last]
      for(target in neighbors[[node]]) {
          if (visited[[target]] == FALSE) {
            levels[[target]] <- levels[[node]] + 1
            queue <- c(queue, target)
            visited[[target]] <- TRUE
          }
      }
      last = last + 1
  }
  levels <- levels[-1]

  return(levels)
}

gen_submitted_orders <- function(compendium, compendiumObjects, path) {
  # Generate a file submission order
  # 
  # Args: 
  #   compendium(data.frame): representing all variables in the dictionary
  #   compendiums_objects:  R object with two lists: 
  #   path(str): path to store submission order file
  # 
  # Returns:
  #   list(str): submission order
  
  nodes <- unique(compendium[['NODE']]) 
  sorted_nodes <- c("project")
  
  for (i in nodes) {
      target <- as.character(compendiumObjects$compendium_nodes[['TARGET']][compendiumObjects$compendium_nodes[['NODE']]==i])
      sorted_nodes <- getOrder(target, i, nodes, sorted_nodes, compendiumObjects$compendium_nodes)
  }   
  sorted_nodes <- sorted_nodes[-1]
  
  # Write importing order
  fileOrder <- paste(sorted_nodes, ".json", sep="")
  write(fileOrder, paste0(path, 'DataImportOrder.txt'))
    
  return(sorted_nodes)
}

getOrder <- function(links, node, nodes, sorted_nodes, nodelinks) {
  # Recursively generate a submission order from current node
  # 
  # Args:
  #     links(list(str)): list of links from current node
  #     node(str): current node
  #     nodes(list(str)): list of node
  #     sorted_nodes(list(str)): containing current submission order
  #     nodelinks(data.frame): containing node links
  # 
  # Returns:
  #     list(str): file submission order
  for (link in links){
    if (!(link %in% sorted_nodes)){
      target <- as.character(nodelinks[['TARGET']][nodelinks[['NODE']]==link])
      sorted_nodes <- getOrder(target, link, nodes, sorted_nodes, nodelinks)
    }
  }
  
  if (!(node %in% sorted_nodes)){
    sorted_nodes <- c(sorted_nodes, node)
  }
  
  return(sorted_nodes)
}

## Run Example: 
#repo <- 'https://github.com/occ-data/bpadictionary'
#repo <- 'https://github.com/NCI-GDC/gdcdictionary'
#branch <- 'develop'
#n <- 1
#dir <- 'SampleFullDictionaryJsonOutput/'
#finalSim <- simFromDictionary(repo, branch, required_only=F, n, output_to_json=T, dir)
