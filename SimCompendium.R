
if(!require(yaml)) install.packages(yaml)
if(!require(httr)) install.packages(httr)

readDictionary <- function(repo, branch) {
    # given github repo, get list of links for each dictionary yaml
    #
    # Args:
    #   repo: top level URL for repo, eg: 'https://github.com/occ-data/bpadictionary'
    #   branch: branch name to use for desired dictionary
    #
    # Returns:
    #   dictionary_nodes:  R object with two lists: 
    #      nodelist: location for all yaml representing dictionary nodes
    #      alt_yaml:  location for all yaml representing persistent definitions, settings and terms
    
    # prep links
    root <- gsub('https://github.com', '', repo)
    api_call <- paste0('https://api.github.com/repos', root, '/git/trees/', branch, '?recursive=1')
    
    # get directory then node names
    directory <- GET(api_call)
    filelist <- unlist(lapply(content(directory)$tree, "[", "path"), use.names = F)
    filelist <- grep("/schemas/", filelist, value = TRUE, fixed = TRUE)
    filelist <- grep(".yaml", filelist, value = TRUE, fixed = TRUE)
    
    # get dictionary nodes and dictionary helpers
    ## filter out exceptions
    altdefs <- grep("/_", filelist, value = TRUE, fixed = TRUE)
    metaschema <- grep("/metaschema.yaml", filelist, value = TRUE, fixed = TRUE)
    program <- grep("/program.yaml", filelist, value = TRUE, fixed = TRUE)
    project <- grep("/project.yaml", filelist, value = TRUE, fixed = TRUE)
    other <- grep("/projects/", filelist, value = TRUE, fixed = TRUE)
    altdefs <- c(altdefs, metaschema, program, project, other)
    nodelist <- filelist[!filelist %in% altdefs]
    
    getNodeURL <- function(node_loc, repo, branch) {
        # given a node name/location, return url to get yaml
        #
        # Args:
        #   node_loc: location in repo of file
        #   repo: top level URL for repo, eg: 'https://github.com/occ-data/bpadictionary'
        #   branch: branch name to use for desired dictionary
        #
        # Returns:
        #   rawURL: URL to GET node yaml
        
        root <- gsub('https://github.com', '', repo)
        rawURL <- paste0('https://raw.githubusercontent.com', root, '/', branch, '/', node_loc)
        return(rawURL)
    }
    
    altdefs <- sapply(altdefs, getNodeURL, repo=repo, branch=branch)
    nodelist <- sapply(nodelist, getNodeURL, repo=repo, branch=branch)
    
    dictionary_nodes <- list(node_list = nodelist,
                             helper_yaml = altdefs)
    return(dictionary_nodes)

}

## Create Node_Compendium and Compendium from Dictionary

buildCompendiums <- function(dictionary) {
    # given the raw dictionary, build a base compendium table
    # and a node relationship table to prep for simulation
    #
    # Args:
    #   dictionary: list of node links generated by the readDictionary 
    #       function
    #
    # Returns:
    #   compendiums_objects:  R object with two lists: 
    #      compendium: representing all variables in the dictionary
    #      compendium_nodes:  representing the relationship between 
    #        nodes in the dictionary
    
    # initialize empty DFs to store objects
    compendium_nodes <- data.frame(NODE = character(), 
                                   TITLE = character(),
                                   CATEGORY = character(),
                                   DESCRIPTION = character(),
                                   LINK_NAME = character(),
                                   BACKREF = character(),
                                   LABEL = character(),
                                   TARGET = character(),
                                   MULTIPLICITY = character(), 
                                   LINK_REQUIRED = character()) 
    compendium <- data.frame(DESCRIPTION = character(),
                             NODE = character(),
                             VARIABLE = character(),
                             REQUIRED = logical(), 
                             TYPE = character(),
                             CHOICES = character(), 
                             TEMPCHOICES = numeric(),
                             MAX = numeric(),
                             MIN = numeric())
    
    # get objects from dictionary
    node_list <- dictionary$node_list
    
    # loop through nodes to generate rows in compendium
    # and compendium nodes
    for (n in node_list) {
        
        # load node yaml
        # error handling if issues with source .yaml
        node <- tryCatch(
            {
                node <- yaml.load_file(n)
            },
            error=function(cond) {
                message(paste("Error loading:", n))
                message(cond)
                message('')
            }
        )  
        
        if(inherits(node, "error")) next
        
        ## Get variables for node relationships df
        
        # get node relationships/links
        links <- unlist(node$links)
        # get compendium_nodes field definitions
        if ('name' %in% names(links)) {
            # if there is no link multiplicity
            link_name <- links[['name']]
            backref <- links[['backref']]
            label <- links[['label']]
            target <- links[['target_type']]
            multiplicity <- links[['multiplicity']]
            link_required <- links[['required']]
        } else if ('subgroup.name' %in% names(links)) {
            link_name <- links[['subgroup.name']]
            backref <- links[['subgroup.backref']]
            label <- links[['subgroup.label']]
            target <- links[['subgroup.target_type']]
            multiplicity <- links[['subgroup.multiplicity']]
            link_required <- links[['subgroup.required']]
        } else {
            link_name <- NA
            backref <- NA
            label <- NA
            target <- NA
            multiplicity <- NA
            link_required <- NA
        }
        
        links_list <- tryCatch(
            {
                links_list <- data.frame(NODE = node$id,
                                         TITLE = node$title,
                                         CATEGORY = node$category,
                                         DESCRIPTION = node$description,
                                         LINK_NAME = link_name,
                                         BACKREF = backref,
                                         LABEL = label,
                                         TARGET = target,
                                         MULTIPLICITY = multiplicity, 
                                         LINK_REQUIRED = link_required)
            },
            error=function(cond) {
                message(paste("Skipping creation of table row ", node$title))
                message('')
            },
            warning=function(cond) {
                message(paste("Warning created: ", node$title))
            }
        )  
        
        if(inherits(links_list, "error")) next

        compendium_nodes <- rbind(compendium_nodes, links_list)
        
        ## Get variables and append to compendium df
    
        NODE <- node$id
        # get list of variables
        fields <- node$properties
        linktoremove <- unlist(node$links)[grepl("name", names(unlist(node$links)))]
        fieldnames <- names(fields) 
        ref <- fields$`$ref`
        
        # check nested props in ref
        if(!is.null(ref)){
            reference <- strsplit(ref,"#/")[[1]]
            reffile <- as.character(dictionary$helper_yaml[grep(reference[1], dictionary$helper_yaml)])
            nested <- tryCatch(
              {
                nested <- yaml.load_file(reffile)
              },
              error=function(cond) {
                message(paste("Error loading:", n))
                message(cond)
                message('')
              }
            )
            nested_fields <- names(nested[[reference[2]]])
            for (f in nested_fields){
                field <- nested[[reference[2]]][[f]]
                if('$ref' %in% names(field)){
                   fields[[f]] <- nested[[f]]
                }
                else{
                   fields[[f]] <- field
                }
            }
            fieldnames <- c(fieldnames, nested_fields)
        }        
        
        #don't include $ref and other internal variables #PROVISIONALLY HARD CODED
        excluded_fields <- c("$ref", "type", "error_type", "state", "id",
                             "file_state", "created_datetime", "updated_datetime",
                             "state", "state_comment", "project_id", "submitter_id",
                             "workflow_start_datetime", "workflow_end_datetime", 
                             "sequencing_date", "run_datetime")
        fieldnames <- fieldnames[!fieldnames %in% linktoremove]
        fieldnames <- fieldnames[!(fieldnames %in% excluded_fields)]
        required <- node$required
        
        # loop through fields in node to get variables
        for (f in fieldnames) {
          
            if ("$ref" %in% names(fields[[f]])){ 
              if ('type' %in% names(fields[[f]]) | 'enum' %in% names(fields[[f]])) next
              else {
                
                # Check nested property
                ref <- fields[[f]]$`$ref`
                reference <- strsplit(ref,"#/")[[1]]
                reffile <- as.character(dictionary$helper_yaml[grep(reference[1], dictionary$helper_yaml)])
                property <- reference[2]
                if (length(reffile) == 0){
                   reffile <- as.character(node_list[grep(reference[1], node_list)])
                   property <- strsplit(property,"/")[[1]]
                }
                definitions <- tryCatch(
                  {
                    definitions <- yaml.load_file(reffile)
                  },
                  error=function(cond) {
                    message(paste("Error loading:", reffile))
                    message(cond)
                    message('')
                  }
                )
                if (length(property) > 1){
                    fields[[f]] <- definitions[[property[1]]][[property[2]]] 
                }
                else{
                    fields[[f]] <- definitions[[property]]
                }
              }
            }
            
            if ('description' %in% names(fields[[f]])) {
                DESCRIPTION = fields[[f]]$description
            } else {
                DESCRIPTION = paste0("See : ", fields[[f]]["term"]$`$ref`)
            }
          
            if ('enum' %in% names(fields[[f]])) {
                TYPE <- 'enum'
                elements <- fields[[f]]$enum
                CHOICES <- paste(elements, collapse='|')
                TEMPCHOICES <- length(elements)
                MAX <- NA
                MIN <- NA                
            } else {
                if ('type' %in% names(fields[[f]])){    
                    TYPE <- fields[[f]]$type[1]
                }              
                else if ('oneOf' %in% names(fields[[f]])){
                    TYPE <- fields[[f]]$oneOf[[1]]$type
                }
                CHOICES <- ''
                if ('pattern' %in% names(fields[[f]])){
                  CHOICES <- fields[[f]]$pattern[1]
                }
                TEMPCHOICES <- 0
                MAX <- NA
                MIN <- NA
                if ('maximum' %in% names(fields[[f]])){
                  MAX <- fields[[f]]$maximum
                }
                if ('minimum' %in% names(fields[[f]])){
                  MIN <- fields[[f]]$minimum
                }                
            }

            if (f %in% required) {
                REQUIRED <- TRUE
            } else {
                REQUIRED <- FALSE
            }
          
            var_list <- tryCatch(
                {
                    var_list <- data.frame(
                        DESCRIPTION = DESCRIPTION,
                        NODE = NODE,
                        VARIABLE = paste0(f, ".", NODE),
                        REQUIRED = REQUIRED,
                        TYPE = TYPE,
                        CHOICES = CHOICES,
                        TEMPCHOICES = TEMPCHOICES,
                        MAX = MAX,
                        MIN = MIN)
                },
                error=function(cond) {
                  message(paste("Error creating variable ", f, " on node ", node$id))
                  message(cond)
                  message('')
                },
                warning=function(cond) {
                  message(paste("Warning created: ", f))
                }                
            ) 
            
            compendium <- rbind(compendium, var_list)
        }
    }
    
    ## Add sim values to compendium
    getEnumProbs <- function(df){
        probs <- c()
        for(i in 1:nrow(df)) {
            row <- df[i,]
            num <- row[['TEMPCHOICES']]
            if (num == '') {probs_new = ''} else {
                probs_new <- paste(rep(1/num, num), collapse='|')
                probs <- c(probs, probs_new)
            }
        }
        return(probs)
    }
    compendium$DESCRIPTION <- as.character(compendium$DESCRIPTION)
    compendium$NODE <- as.character(compendium$NODE)
    compendium$VARIABLE <- as.character(compendium$VARIABLE)
    compendium$CHOICES <- as.character(compendium$CHOICES)
    compendium$TYPE <- as.character(compendium$TYPE)
    
    compendium$PROBS <- getEnumProbs(compendium)
    compendium$PROBS[compendium$TYPE=='boolean'] <- c('.4|.6')
    compendium$TEMPCHOICES <- NULL
    
    compendium$DISTRIB <- ''
    compendium$DISTRIB[compendium$TYPE=='integer'] <- 'poisson'
    compendium$DISTRIB[compendium$TYPE=='number'] <- 'normal'
    
    compendium$DISTRIB.INPUTS <- ''
    compendium$DISTRIB.INPUTS[compendium$TYPE=='integer'] <- 'lambda = 4'
    compendium$DISTRIB.INPUTS[compendium$TYPE=='number'] <- 'mean = 10, sd = 3'
    
    # update number/integer distribution if a range is provided
    means <- (compendium$MAX[compendium$TYPE=='integer' &!is.na(compendium$MIN)] + compendium$MIN[compendium$TYPE=='integer' &!is.na(compendium$MIN)]) / 2         
    compendium$DISTRIB.INPUTS[compendium$TYPE=='integer' & !is.na(compendium$MIN)] <- paste("lambda = ", as.character(means), sep="")
    means <- (compendium$MAX[compendium$TYPE=='number' &!is.na(compendium$MIN)] + compendium$MIN[compendium$TYPE=='number' &!is.na(compendium$MIN)]) / 2         
    compendium$DISTRIB.INPUTS[compendium$TYPE=='number' & !is.na(compendium$MIN)] <- paste("mean = ", as.character(means), ", sd = 10", sep="")

    
    compendium$NAS <- runif(nrow(compendium), 0, .2)
    compendium$POSITIVEONLY <- ''
    
    # create final object with compendium and compendium node relationships
    compendium_objects <- list(compendium = compendium,
                               compendium_nodes = compendium_nodes)
    return(compendium_objects)
}


simFromDictionary <- function(repo, branch, project_name, required_only=F, n, output_to_json=F, dir=NULL) {
    # given the raw dictionary, build a base compendium table
    # and a node relationship table and run simulation
    #
    # Args:
    #   repo: top level URL for repo, eg: 'https://github.com/occ-data/bpadictionary'
    #   branch: branch name to use for desired dictionary
    #   required_only: to subset compendium so that only required fields are simmed
    #   n: number of sims for each variable
    #   output_to_json:  create output json files
    #   dir: output for json files
    #
    # Returns:
    #   simdata and json files in output directory
    
    print("Loading Simulation Tools...")
    #source('https://raw.githubusercontent.com/occ-data/data-simulator/master/SimtoJson.R')
    #source('https://raw.githubusercontent.com/occ-data/data-simulator/master/SimData.R')
    source('SimtoJson.R')
    source('SimData.R')
    
    print("Getting URLs for Each Node...") 
    dictionary <- readDictionary(repo, branch)
    
    print("Creating Compendium and Node Relationship Table...")
    compendiumObjects <- buildCompendiums(dictionary)
    compendium <- compendiumObjects$compendium
    
    if (required_only) {
        compendium <- compendium[compendium$REQUIRED==TRUE,]
    } 
    
    nodes <- unique(compendium[['NODE']])
    
    print("Simulating Data...")
    simdata <- simData(compendium, 
                       n, 
                       include.na = FALSE, 
                       reject= FALSE)
    if (output_to_json) {
        print("Generating Json...")
        SimtoJson(simdata, 
                  compendium, 
                  compendiumObjects$compendium_nodes,
                  project_name,
                  dir)
    }
    
    return(simdata)

}

## Run Example: 
#repo <- 'https://github.com/occ-data/bpadictionary'
#repo <- 'https://github.com/NCI-GDC/gdcdictionary'
#branch <- 'develop'
#n <- 1
#dir <- 'SampleFullDictionaryJsonOutput/'
#finalSim <- simFromDictionary(repo, branch, required_only=F, n, output_to_json=T, dir)
